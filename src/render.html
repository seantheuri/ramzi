<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üéõÔ∏è RAMZI DJ Studio - Mix Renderer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        color: white;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .header {
        text-align: center;
        padding: 20px;
        background: rgba(0, 0, 0, 0.3);
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      /* Upload Section */
      .upload-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        text-align: center;
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
        cursor: pointer;
        margin: 20px 0;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .file-input-label {
        display: block;
        padding: 20px 40px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px dashed rgba(255, 255, 255, 0.3);
      }

      .file-input-label:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
      }

      .btn {
        padding: 12px 30px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 10px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* DJ Dashboard */
      .dj-dashboard {
        display: grid;
        grid-template-columns: 1fr 300px 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }

      .deck {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .deck-header {
        text-align: center;
        margin-bottom: 20px;
        padding: 10px;
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
        border-radius: 8px;
        font-weight: bold;
        font-size: 1.2em;
      }

      .deck-a .deck-header {
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      }

      .deck-b .deck-header {
        background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
      }

      .waveform {
        display: none; /* Hide fake deck waveforms */
      }

      .waveform-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .playhead {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #00ff00;
        z-index: 10;
        transition: left 0.1s linear;
      }

      .deck-controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin: 15px 0;
      }

      .control-btn {
        padding: 8px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        font-size: 0.9em;
        transition: all 0.2s ease;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .control-btn.active {
        background: #4ecdc4;
      }

      /* Mixer Section */
      .mixer {
        background: rgba(0, 0, 0, 0.6);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .mixer-header {
        text-align: center;
        margin-bottom: 20px;
        font-weight: bold;
        font-size: 1.1em;
      }

      .crossfader-section {
        margin: 20px 0;
      }

      .crossfader {
        width: 100%;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        position: relative;
        margin: 10px 0;
      }

      .crossfader-handle {
        position: absolute;
        top: 2px;
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 50%;
        transition: left 0.2s ease;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .eq-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin: 20px 0;
      }

      .eq-channel {
        text-align: center;
      }

      .eq-knob {
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        margin: 5px auto;
        position: relative;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .eq-knob::after {
        content: "";
        position: absolute;
        top: 5px;
        left: 50%;
        width: 2px;
        height: 15px;
        background: white;
        transform: translateX(-50%);
        transform-origin: center 20px;
        transition: transform 0.2s ease;
      }

      /* Timeline */
      .timeline-section {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .timeline-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .timeline-controls {
        display: flex;
        gap: 10px;
      }

      .timeline {
        height: 120px; /* taller for easier interaction */
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
        margin: 15px 0;
      }

      .timeline-track {
        position: absolute;
        top: 0;
        height: 100%;
        display: flex;
        align-items: center;
        padding: 0 10px;
      }

      .timeline-playhead {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 3px;
        background: #00ff00;
        z-index: 30;
        transition: left 0.2s linear;
      }

      .command-marker {
        position: absolute;
        width: 4px;
        height: 100%;
        background: #ffab00;
        opacity: 0.8;
        z-index: 10;
      }

      .command-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 0.8em;
        white-space: nowrap;
        display: none;
        z-index: 30;
      }

      .command-marker:hover .command-tooltip {
        display: block;
      }

      /* Status Panel */
      .status-panel {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
      }

      .status-item {
        text-align: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .status-value {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .status-label {
        font-size: 0.9em;
        opacity: 0.7;
      }

      /* Progress Bar */
      .progress-bar {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4ecdc4, #44a08d);
        transition: width 0.3s ease;
        width: 0%;
      }

      /* Error/Success Messages */
      .message {
        padding: 15px;
        border-radius: 8px;
        margin: 15px 0;
        display: none;
      }

      .error-message {
        background: rgba(255, 107, 107, 0.2);
        border: 1px solid rgba(255, 107, 107, 0.5);
        color: #ff6b6b;
      }

      .success-message {
        background: rgba(76, 175, 80, 0.2);
        border: 1px solid rgba(76, 175, 80, 0.5);
        color: #4caf50;
      }

      .show {
        display: block !important;
      }

      /* Animations */
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .pulse {
        animation: pulse 1s infinite;
      }

      @keyframes glow {
        0%,
        100% {
          box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }
        50% {
          box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
        }
      }

      .glow {
        animation: glow 2s infinite;
      }

      /* Responsive Design */
      @media (max-width: 1200px) {
        .dj-dashboard {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto auto;
        }

        .mixer {
          order: -1;
        }
      }

      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }

        .eq-section {
          grid-template-columns: 1fr;
        }

        .status-grid {
          grid-template-columns: 1fr;
        }
      }

      /* Transition Log */
      .transition-log {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-height: 200px;
        overflow-y: auto;
        font-size: 0.9em;
      }

      .timeline-waveform {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>üéõÔ∏è RAMZI DJ Studio</h1>
      <p>Upload your mix script and watch the magic happen in real-time</p>
    </div>

    <div class="container">
      <!-- Upload Section -->
      <div class="upload-section">
        <h2>üìÅ Upload Mix Script</h2>
        <p>Select a JSON mix script file generated by the AI mixer</p>

        <div class="file-input-wrapper">
          <input type="file" id="scriptFile" accept=".json" />
          <label for="scriptFile" class="file-input-label">
            <span class="upload-text">üéµ Choose Mix Script (.json)</span>
          </label>
        </div>

        <div id="scriptInfo" style="display: none; margin-top: 15px">
          <p><strong>Script:</strong> <span id="scriptName"></span></p>
          <p><strong>Duration:</strong> <span id="scriptDuration"></span></p>
          <p><strong>Commands:</strong> <span id="scriptCommands"></span></p>
        </div>

        <button class="btn btn-primary" id="startRenderBtn" disabled>
          üéõÔ∏è Start Mix Rendering
        </button>
      </div>

      <!-- Status Panel -->
      <div class="status-panel">
        <h3>üìä Mix Status</h3>
        <div class="status-grid">
          <div class="status-item">
            <div class="status-value" id="currentTime">00:00</div>
            <div class="status-label">Current Time</div>
          </div>
          <div class="status-item">
            <div class="status-value" id="totalDuration">00:00</div>
            <div class="status-label">Total Duration</div>
          </div>
          <div class="status-item">
            <div class="status-value" id="renderProgress">0%</div>
            <div class="status-label">Render Progress</div>
          </div>
          <div class="status-item">
            <div class="status-value" id="activeCommands">0</div>
            <div class="status-label">Active Commands</div>
          </div>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="mainProgressFill"></div>
        </div>
      </div>

      <!-- DJ Dashboard -->
      <div class="dj-dashboard">
        <!-- Deck A -->
        <div class="deck deck-a">
          <div class="deck-header">DECK A</div>
          <div class="waveform">
            <canvas class="waveform-canvas" id="waveformA"></canvas>
            <div class="playhead" id="playheadA"></div>
          </div>
          <div class="deck-controls">
            <button class="control-btn" id="playA">‚ñ∂Ô∏è PLAY</button>
            <button class="control-btn" id="cueA">üéØ CUE</button>
            <button class="control-btn" id="syncA">üîÑ SYNC</button>
          </div>
          <div class="eq-section">
            <div class="eq-channel">
              <div class="eq-knob" id="eqHighA"></div>
              <label>HIGH</label>
            </div>
          </div>
        </div>

        <!-- Mixer -->
        <div class="mixer">
          <div class="mixer-header">üéõÔ∏è MIXER</div>
          <div class="crossfader-section">
            <label>CROSSFADER</label>
            <div class="crossfader">
              <div class="crossfader-handle" id="crossfaderHandle"></div>
            </div>
            <div
              style="
                display: flex;
                justify-content: space-between;
                font-size: 0.8em;
              "
            >
              <span>A</span>
              <span>B</span>
            </div>
          </div>
          <div class="eq-section">
            <div class="eq-channel">
              <h4>DECK A</h4>
              <div class="eq-knob" id="mixerEqHighA"></div>
              <div class="eq-knob" id="mixerEqMidA"></div>
              <div class="eq-knob" id="mixerEqLowA"></div>
            </div>
            <div class="eq-channel">
              <h4>DECK B</h4>
              <div class="eq-knob" id="mixerEqHighB"></div>
              <div class="eq-knob" id="mixerEqMidB"></div>
              <div class="eq-knob" id="mixerEqLowB"></div>
            </div>
          </div>
        </div>

        <!-- Deck B -->
        <div class="deck deck-b">
          <div class="deck-header">DECK B</div>
          <div class="waveform">
            <canvas class="waveform-canvas" id="waveformB"></canvas>
            <div class="playhead" id="playheadB"></div>
          </div>
          <div class="deck-controls">
            <button class="control-btn" id="playB">‚ñ∂Ô∏è PLAY</button>
            <button class="control-btn" id="cueB">üéØ CUE</button>
            <button class="control-btn" id="syncB">üîÑ SYNC</button>
          </div>
          <div class="eq-section">
            <div class="eq-channel">
              <div class="eq-knob" id="eqHighB"></div>
              <label>HIGH</label>
            </div>
          </div>
        </div>
      </div>

      <!-- Timeline -->
      <div class="timeline-section">
        <div class="timeline-header">
          <h3>‚è±Ô∏è Mix Timeline</h3>
          <div class="timeline-controls">
            <button class="btn control-btn" id="playTimelineBtn">
              ‚ñ∂Ô∏è Play
            </button>
            <button class="btn control-btn" id="pauseTimelineBtn">
              ‚è∏Ô∏è Pause
            </button>
            <button class="btn control-btn" id="stopTimelineBtn">
              ‚èπÔ∏è Stop
            </button>
          </div>
        </div>
        <div class="timeline" id="timeline">
          <canvas id="timelineWaveform" class="timeline-waveform"></canvas>
          <div class="timeline-playhead" id="timelinePlayhead"></div>
        </div>
      </div>

      <!-- Audio Player -->
      <div
        class="audio-player-section"
        id="audioPlayerSection"
        style="display: none"
      >
        <div
          style="
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
          "
        >
          <h3>üéµ Live Mix Playback</h3>
          <audio
            controls
            id="mixAudio"
            style="width: 100%; max-width: 600px; margin: 20px 0"
          >
            Your browser does not support the audio element.
          </audio>
          <div style="margin-top: 15px">
            <button class="btn btn-primary" id="playMixBtn">‚ñ∂Ô∏è Play Mix</button>
            <button class="btn btn-primary" id="pauseMixBtn">‚è∏Ô∏è Pause</button>
            <button class="btn btn-primary" id="restartMixBtn">
              ‚èÆÔ∏è Restart
            </button>
          </div>
        </div>
      </div>

      <!-- Messages -->
      <div class="error-message" id="errorMessage"></div>
      <div class="success-message" id="successMessage"></div>

      <!-- Transition Log -->
      <div class="transition-log" id="transitionLog">
        <h3>üìù Transition Log</h3>
        <div id="logEntries"></div>
      </div>
    </div>

    <script>
      // Configuration
      const API_BASE =
        window.location.hostname === "localhost" ||
        window.location.hostname === "127.0.0.1"
          ? "http://127.0.0.1:5000/api"
          : "/api";

      // Global variables
      let mixScript = null;
      let isRendering = false;
      let isPlaying = false;
      let animationId = null;
      let currentCommandIndex = 0;
      let renderedAudioUrl = null;

      // DOM elements
      const scriptFileInput = document.getElementById("scriptFile");
      const scriptInfo = document.getElementById("scriptInfo");
      const startRenderBtn = document.getElementById("startRenderBtn");
      const errorMessage = document.getElementById("errorMessage");
      const successMessage = document.getElementById("successMessage");

      // Status elements
      const currentTimeEl = document.getElementById("currentTime");
      const totalDurationEl = document.getElementById("totalDuration");
      const renderProgressEl = document.getElementById("renderProgress");
      const activeCommandsEl = document.getElementById("activeCommands");
      const mainProgressFill = document.getElementById("mainProgressFill");

      // Timeline elements
      const timeline = document.getElementById("timeline");
      const timelineWaveform = document.getElementById("timelineWaveform");
      const timelinePlayhead = document.getElementById("timelinePlayhead");
      const playTimelineBtn = document.getElementById("playTimelineBtn");
      const pauseTimelineBtn = document.getElementById("pauseTimelineBtn");
      const stopTimelineBtn = document.getElementById("stopTimelineBtn");

      // Deck elements
      const playheadA = document.getElementById("playheadA");
      const playheadB = document.getElementById("playheadB");
      const crossfaderHandle = document.getElementById("crossfaderHandle");

      // Audio elements
      const audioPlayerSection = document.getElementById("audioPlayerSection");
      const mixAudio = document.getElementById("mixAudio");
      const playMixBtn = document.getElementById("playMixBtn");
      const pauseMixBtn = document.getElementById("pauseMixBtn");
      const restartMixBtn = document.getElementById("restartMixBtn");

      // Utility functions
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, "0")}:${secs
          .toString()
          .padStart(2, "0")}`;
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.add("show");
        setTimeout(() => errorMessage.classList.remove("show"), 5000);
      }

      function showSuccess(message) {
        successMessage.textContent = message;
        successMessage.classList.add("show");
        setTimeout(() => successMessage.classList.remove("show"), 5000);
      }

      // File upload handler
      scriptFileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          mixScript = JSON.parse(text);

          // Validate script structure
          if (!mixScript.script || !Array.isArray(mixScript.script)) {
            throw new Error("Invalid mix script format");
          }

          // Display script info
          document.getElementById("scriptName").textContent = file.name;
          document.getElementById("scriptDuration").textContent = formatTime(
            mixScript.total_duration || 0
          );
          document.getElementById("scriptCommands").textContent =
            mixScript.script.length;

          scriptInfo.style.display = "block";
          startRenderBtn.disabled = false;

          // Update total duration display
          totalDurationEl.textContent = formatTime(
            mixScript.total_duration || 0
          );

          // Create timeline markers
          createTimelineMarkers();

          showSuccess("Mix script loaded successfully!");
        } catch (error) {
          showError(`Error loading script: ${error.message}`);
          mixScript = null;
          scriptInfo.style.display = "none";
          startRenderBtn.disabled = true;
        }
      });

      // Create timeline markers for commands
      function createTimelineMarkers() {
        if (!mixScript) return;

        // Clear existing markers
        const existingMarkers = timeline.querySelectorAll(".command-marker");
        existingMarkers.forEach((marker) => marker.remove());

        const totalDuration = mixScript.total_duration || 300;

        mixScript.script.forEach((command, index) => {
          const marker = document.createElement("div");
          marker.className = "command-marker";
          marker.style.left = `${(command.time / totalDuration) * 100}%`;

          const tooltip = document.createElement("div");
          tooltip.className = "command-tooltip";
          tooltip.textContent = `${formatTime(command.time)}: ${
            command.command
          }`;
          marker.appendChild(tooltip);

          timeline.appendChild(marker);
        });

        // Draw waveform markers
        drawWaveformMarkers();
      }

      // Draw waveform markers
      function drawWaveformMarkers() {
        if (!mixScript) return;
        const totalDuration = mixScript.total_duration || 300;
        [
          document.getElementById("waveformA"),
          document.getElementById("waveformB"),
        ].forEach((canvas) => {
          const ctx = canvas.getContext("2d");
          const width = canvas.width;
          const height = canvas.height;
          // redraw placeholder first
          ctx.clearRect(0, 0, width, height);
          ctx.strokeStyle = "rgba(255,255,255,0.3)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          for (let i = 0; i < width; i += 2) {
            const y = height / 2 + Math.sin(i * 0.02) * 20 * Math.random();
            if (i === 0) ctx.moveTo(i, y);
            else ctx.lineTo(i, y);
          }
          ctx.stroke();

          // markers
          ctx.strokeStyle = "#ffab00";
          ctx.lineWidth = 2;
          mixScript.script.forEach((cmd) => {
            const x = (cmd.time / totalDuration) * width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          });
        });
      }

      // Start rendering
      startRenderBtn.addEventListener("click", async () => {
        if (!mixScript || isRendering) return;

        try {
          isRendering = true;
          currentCommandIndex = 0;

          startRenderBtn.disabled = true;
          startRenderBtn.textContent = "üéõÔ∏è Rendering Audio...";

          showSuccess("üéõÔ∏è Rendering audio - this may take a few minutes...");

          // Send script to backend for audio rendering
          const response = await fetch(`${API_BASE}/render-mix`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(mixScript),
          });

          if (!response.ok) {
            throw new Error("Failed to start rendering");
          }

          const result = await response.json();

          if (result.success) {
            showSuccess(
              "üéµ Audio rendered successfully! Loading for playback..."
            );

            // Set up audio for playback (avoid double /api prefix)
            const API_ROOT = API_BASE.endsWith("/api")
              ? API_BASE.slice(0, -4)
              : API_BASE;
            renderedAudioUrl = result.download_url.startsWith("http")
              ? result.download_url
              : `${API_ROOT}${result.download_url}`;
            mixAudio.src = renderedAudioUrl;

            // Show audio player
            audioPlayerSection.style.display = "block";

            // Update button text
            startRenderBtn.textContent = "‚úÖ Audio Ready - Use Player Below";

            showSuccess(
              "üéµ Ready to play! Use the audio controls below to start the mix and watch the live visualization!"
            );
          } else {
            throw new Error(result.error || "Rendering failed");
          }
        } catch (error) {
          showError(`Rendering failed: ${error.message}`);
          stopRendering();
        }
      });

      // Update visualization synced with audio playback
      function updateVisualization() {
        if (!isPlaying || !mixScript || !mixAudio) return;

        const currentTime = mixAudio.currentTime;
        const totalDuration = mixScript.total_duration || 300;
        const progress = Math.min(currentTime / totalDuration, 1);

        // Update time displays
        currentTimeEl.textContent = formatTime(currentTime);
        renderProgressEl.textContent = `${Math.round(progress * 100)}%`;
        mainProgressFill.style.width = `${progress * 100}%`;

        // Update timeline playhead
        timelinePlayhead.style.left = `${progress * 100}%`;

        // Process commands at current time
        processCommandsAtTime(currentTime);

        // Continue animation if still playing
        if (!mixAudio.paused && !mixAudio.ended) {
          animationId = requestAnimationFrame(updateVisualization);
        } else {
          isPlaying = false;
          if (mixAudio.ended) {
            showSuccess("üéµ Mix playback completed!");
            resetVisualization();
          }
        }
      }

      // Process commands at current time
      function processCommandsAtTime(currentTime) {
        let activeCommands = 0;

        // Process all commands up to current time
        while (currentCommandIndex < mixScript.script.length) {
          const command = mixScript.script[currentCommandIndex];

          if (command.time <= currentTime) {
            executeVisualCommand(command);
            currentCommandIndex++;
            activeCommands++;
          } else {
            break;
          }
        }

        activeCommandsEl.textContent = activeCommands;
      }

      // Execute visual command effects
      function executeVisualCommand(command) {
        const params = command.params || {};
        const deck = params.deck;

        console.log(`Executing: ${command.command}`, params);

        switch (command.command) {
          case "play":
            logTransition(command.time, `‚ñ∂Ô∏è PLAY on Deck ${deck}`);
            if (deck === "A") {
              document.getElementById("playA").classList.add("active");
              playheadA.style.animationPlayState = "running";
            } else if (deck === "B") {
              document.getElementById("playB").classList.add("active");
              playheadB.style.animationPlayState = "running";
            }
            break;

          case "pause":
          case "stop":
            logTransition(
              command.time,
              `‚è∏Ô∏è ${command.command.toUpperCase()} on Deck ${deck}`
            );
            if (deck === "A") {
              document.getElementById("playA").classList.remove("active");
              playheadA.style.animationPlayState = "paused";
            } else if (deck === "B") {
              document.getElementById("playB").classList.remove("active");
              playheadB.style.animationPlayState = "paused";
            }
            break;

          case "set_crossfader":
            const position = params.position || 0;
            const leftPercent = position * 100;
            crossfaderHandle.style.left = `calc(${leftPercent}% - 18px)`;
            logTransition(
              command.time,
              `üéöÔ∏è Crossfader to ${(position * 100).toFixed(0)}%`
            );
            break;

          case "set_parameter":
            updateEQVisualization(params);
            logTransition(
              command.time,
              `üéõÔ∏è ${params.parameter} on Deck ${deck} ‚Üí ${(
                params.value * 100
              ).toFixed(0)}%`
            );
            break;

          case "beat_sync":
            logTransition(command.time, `üîÑ Beat Sync on Deck ${deck}`);
            if (deck === "A") {
              document.getElementById("syncA").classList.add("active", "glow");
              setTimeout(() => {
                document.getElementById("syncA").classList.remove("glow");
              }, 2000);
            } else if (deck === "B") {
              document.getElementById("syncB").classList.add("active", "glow");
              setTimeout(() => {
                document.getElementById("syncB").classList.remove("glow");
              }, 2000);
            }
            break;

          case "set_hot_cue":
          case "jump_hot_cue":
            // Add visual feedback for cue actions
            if (deck === "A") {
              document.getElementById("cueA").classList.add("pulse");
              setTimeout(
                () => document.getElementById("cueA").classList.remove("pulse"),
                1000
              );
            } else if (deck === "B") {
              document.getElementById("cueB").classList.add("pulse");
              setTimeout(
                () => document.getElementById("cueB").classList.remove("pulse"),
                1000
              );
            }
            break;
        }
      }

      // Update EQ visualization
      function updateEQVisualization(params) {
        const deck = params.deck;
        const parameter = params.parameter;
        const value = params.value;

        let elementId = "";

        if (parameter === "eq_high") {
          elementId = deck === "A" ? "mixerEqHighA" : "mixerEqHighB";
        } else if (parameter === "eq_mid") {
          elementId = deck === "A" ? "mixerEqMidA" : "mixerEqMidB";
        } else if (parameter === "eq_low") {
          elementId = deck === "A" ? "mixerEqLowA" : "mixerEqLowB";
        }

        if (elementId) {
          const element = document.getElementById(elementId);
          if (element) {
            // Convert value (0-1) to rotation (-135deg to +135deg)
            const rotation = (value - 0.5) * 270;
            element.style.transform = `rotate(${rotation}deg)`;

            // Add visual feedback
            element.classList.add("glow");
            setTimeout(() => element.classList.remove("glow"), 500);
          }
        }
      }

      // Stop rendering/playback
      function stopRendering() {
        isRendering = false;
        isPlaying = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }

        startRenderBtn.disabled = false;
        startRenderBtn.textContent = "üéõÔ∏è Start Mix Rendering";

        // Reset visual states
        resetVisualization();
      }

      // Reset visualization to initial state
      function resetVisualization() {
        currentCommandIndex = 0;
        currentTimeEl.textContent = "00:00";
        renderProgressEl.textContent = "0%";
        mainProgressFill.style.width = "0%";
        timelinePlayhead.style.left = "0%";
        activeCommandsEl.textContent = "0";

        // Reset all visual states
        document.querySelectorAll(".control-btn.active").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Reset crossfader to center
        crossfaderHandle.style.left = "calc(50% - 18px)";

        // Reset EQ knobs
        document.querySelectorAll(".eq-knob").forEach((knob) => {
          knob.style.transform = "rotate(0deg)";
        });
      }

      // Timeline controls
      playTimelineBtn.addEventListener("click", () => {
        if (!isRendering && mixScript) {
          startRenderBtn.click();
        }
      });

      pauseTimelineBtn.addEventListener("click", () => {
        if (isRendering) {
          stopRendering();
        }
      });

      stopTimelineBtn.addEventListener("click", () => {
        stopRendering();
        currentTimeEl.textContent = "00:00";
        renderProgressEl.textContent = "0%";
        mainProgressFill.style.width = "0%";
        timelinePlayhead.style.left = "0%";
        currentCommandIndex = 0;
      });

      // Seek on timeline click
      timeline.addEventListener("click", (e) => {
        if (!mixScript || !mixAudio.duration) return;
        const rect = timeline.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const pct = clickX / rect.width;
        mixAudio.currentTime = pct * mixAudio.duration;
        resetVisualization();
        if (!mixAudio.paused) {
          requestAnimationFrame(updateVisualization);
        } else {
          // update playhead immediately
          timelinePlayhead.style.left = `${pct * 100}%`;
        }
      });

      // Audio player controls
      playMixBtn.addEventListener("click", () => {
        if (mixAudio.src && !isPlaying) {
          resetVisualization(); // Reset before playing
          mixAudio.play();
          isPlaying = true;
          requestAnimationFrame(updateVisualization);
          showSuccess("üéµ Mix playback started! Watch the live visualization!");
        }
      });

      pauseMixBtn.addEventListener("click", () => {
        if (isPlaying) {
          mixAudio.pause();
          isPlaying = false;
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
        }
      });

      restartMixBtn.addEventListener("click", () => {
        mixAudio.currentTime = 0;
        resetVisualization();
        if (!mixAudio.paused) {
          isPlaying = true;
          requestAnimationFrame(updateVisualization);
        }
      });

      // Audio events
      mixAudio.addEventListener("play", () => {
        if (!isPlaying) {
          isPlaying = true;
          requestAnimationFrame(updateVisualization);
        }
      });

      mixAudio.addEventListener("pause", () => {
        isPlaying = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
      });

      mixAudio.addEventListener("ended", () => {
        isPlaying = false;
        resetVisualization();
        showSuccess("üéµ Mix playback completed!");
      });

      // resize handler updates timeline width for playhead
      window.addEventListener("resize", () => {
        if (mixScript) {
          timelinePlayhead.style.left = `${
            (mixAudio.currentTime / (mixScript.total_duration || 1)) * 100
          }%`;
        }
      });

      // Drawing waveform after audio loaded
      mixAudio.addEventListener("loadedmetadata", () => {
        drawTimelineWaveform();
      });

      async function drawTimelineWaveform() {
        try {
          const resp = await fetch(renderedAudioUrl);
          const arrayBuf = await resp.arrayBuffer();
          const audioCtx = new (window.AudioContext ||
            window.webkitAudioContext)();
          const audioBuf = await audioCtx.decodeAudioData(arrayBuf);
          const width = timeline.clientWidth;
          const height = timeline.clientHeight;
          timelineWaveform.width = width;
          timelineWaveform.height = height;
          const data = audioBuf.getChannelData(0);
          const samplesPerPixel = data.length / width;
          twCtx.clearRect(0, 0, width, height);
          twCtx.strokeStyle = "rgba(255,255,255,0.6)";
          twCtx.lineWidth = 1;
          twCtx.beginPath();
          for (let x = 0; x < width; x++) {
            const start = Math.floor(x * samplesPerPixel);
            const end = Math.floor((x + 1) * samplesPerPixel);
            let min = 1.0,
              max = -1.0;
            for (let i = start; i < end; i++) {
              const val = data[i] || 0;
              if (val < min) min = val;
              if (val > max) max = val;
            }
            const y1 = height / 2 + (min * height) / 2;
            const y2 = height / 2 + (max * height) / 2;
            twCtx.moveTo(x, y1);
            twCtx.lineTo(x, y2);
          }
          twCtx.stroke();
          // redraw command markers on canvas above waveform? markers are divs so okay
        } catch (e) {
          console.error("Waveform draw error", e);
        }
      }

      const logContainer = document.getElementById("logEntries");

      function logTransition(timeSec, text) {
        const p = document.createElement("p");
        p.className = "log-entry";
        p.dataset.time = timeSec;
        p.innerHTML = `<span style="font-family:monospace;opacity:0.7">${formatTime(
          timeSec
        )}</span> ‚Äì ${text}`;
        p.style.cursor = "pointer";
        p.addEventListener("click", () => {
          mixAudio.currentTime = timeSec;
          resetVisualization();
          if (!mixAudio.paused) requestAnimationFrame(updateVisualization);
        });
        logContainer.prepend(p);
        if (logContainer.children.length > 200) {
          logContainer.removeChild(logContainer.lastChild);
        }
      }
    </script>
  </body>
</html>
